<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>bevy_ecs_ldtk Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">Tutorials</li><li class="chapter-item expanded "><a href="tutorials/tile-based-game/index.html"><strong aria-hidden="true">1.</strong> Tile-based Game</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tutorials/tile-based-game/create-your-ldtk-project.html"><strong aria-hidden="true">1.1.</strong> Create your LDtk project</a></li><li class="chapter-item expanded "><a href="tutorials/tile-based-game/spawn-your-ldtk-project-in-bevy.html"><strong aria-hidden="true">1.2.</strong> Spawn your LDtk project in Bevy</a></li><li class="chapter-item expanded "><a href="tutorials/tile-based-game/add-gameplay-to-your-project.html"><strong aria-hidden="true">1.3.</strong> Add gameplay to your project</a></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">2.</strong> Platformer</div></li><li class="chapter-item expanded affix "><li class="part-title">Explanation</li><li class="chapter-item expanded "><a href="explanation/level-selection.html"><strong aria-hidden="true">3.</strong> Level Selection</a></li><li class="chapter-item expanded "><a href="explanation/game-logic-integration.html"><strong aria-hidden="true">4.</strong> Game Logic Integration</a></li><li class="chapter-item expanded "><a href="explanation/anatomy-of-the-world.html"><strong aria-hidden="true">5.</strong> Anatomy of the World</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Plugin Schedule</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.</strong> Asset Model</div></li><li class="chapter-item expanded affix "><li class="part-title">How-To Guides</li><li class="chapter-item expanded "><div><strong aria-hidden="true">8.</strong> Register Bundles for Intgrid Tiles and LDtk Entities</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">9.</strong> Process Entities Further with Blueprints</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">10.</strong> Combine Tiles into Larger Entities</div></li><li class="chapter-item expanded "><a href="how-to-guides/create-bevy-relations-from-ldtk-entity-references.html"><strong aria-hidden="true">11.</strong> Create Bevy Relations from LDtk Entity References</a></li><li class="chapter-item expanded "><a href="how-to-guides/respawn-levels-and-worlds.html"><strong aria-hidden="true">12.</strong> Respawn Levels and Worlds</a></li><li class="chapter-item expanded "><a href="how-to-guides/make-level-selection-follow-player.html"><strong aria-hidden="true">13.</strong> Make LevelSelection Follow Player</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">14.</strong> Animate Tiles</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.</strong> Camera Logic</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">15.1.</strong> Implement Fit-Inside Camera</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.2.</strong> Implement Fit-Around Camera</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">15.3.</strong> Implement Parallax</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">16.</strong> Retrieve Field Instance Data</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">17.</strong> Retrieve Loaded Level Data</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">18.</strong> Compile to WASM</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">19.</strong> Compile Headless</div></li><li class="chapter-item expanded "><a href="how-to-guides/migration-guides/index.html"><strong aria-hidden="true">20.</strong> Migration Guides</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="how-to-guides/migration-guides/migrate-from-0.8-to-0.9.html"><strong aria-hidden="true">20.1.</strong> Migrate from 0.8 to 0.9</a></li><li class="chapter-item expanded "><a href="how-to-guides/migration-guides/migrate-from-0.9-to-0.10.html"><strong aria-hidden="true">20.2.</strong> Migrate from 0.9 to 0.10</a></li><li class="spacer"></li></ol></li><li class="chapter-item expanded "><a href="api-reference.html">API Reference</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">bevy_ecs_ldtk Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<h2 id="bevy_ecs_ldtk"><a class="header" href="#bevy_ecs_ldtk"><code>bevy_ecs_ldtk</code></a></h2>
<p><a href="https://crates.io/crates/bevy_ecs_ldtk"><code>bevy_ecs_ldtk</code></a> is an ECS-friendly <a href="https://ldtk.io/">LDtk</a> plugin for <a href="https://bevyengine.org/">Bevy</a>.
It allows you to use LDtk projects as an asset, spawn levels, and insert bevy components/bundles on LDtk entities/tiles.
This plugin is ECS-friendly, partly for its internal usage of ECS that provides extra functionality to users, and partly for its usage of <a href="https://crates.io/crates/bevy_ecs_tilemap"><code>bevy_ecs_tilemap</code></a> for rendering tilemaps.
This is all behind an ergonomic API, providing low-boilerplate solutions to common use cases.
For less common use cases, strategies that leverage this plugin's ECS constructs are also available.</p>
<h2 id="this-book"><a class="header" href="#this-book">This book</a></h2>
<p>This book is a work in progress, but aims to provide the following pieces of documentation:</p>
<ul>
<li>tutorials: lessons detailing the creation of simple games from start to finish</li>
<li>explanation: clarification of concepts and strategies employed by <code>bevy_ecs_ldtk</code>, including details about how it works and why</li>
<li>how-to guides: recommended solutions to common problems, as well as migration guides</li>
</ul>
<p>This book is not an API reference.
For that, please refer to <code>bevy_ecs_ldtk</code>'s documentation on <a href="https://docs.rs/bevy_ecs_ldtk/">docs.rs</a>.</p>
<p>While this book aims to be comprehensive, it should also be easy to maintain and up-to-date.
This is why, in consort with the API reference, documentation for <code>bevy_ecs_ldtk</code> aims to satisfy <a href="https://documentation.divio.com/">The Grand Unified Theory of Documentation</a>.
Furthermore, code snippets in this book are automatically tested by <code>bevy_ecs_ldtk</code>'s CI wherever possible with the help of <a href="https://github.com/tfpk/mdbook-keeper/">mdBook-Keeper</a>.
This should help inform maintainers when changes to the plugin have made documentation out-of-date.
Deployment of this book to github pages is also performed by <code>bevy_ecs_ldtk</code>'s CI automatically on new releases.</p>
<p>Splitting the documentation up this way means that this book is not necessarily meant to be read in order.
Some chapters are intended to be read while working on your own project, while others are meant to be more like studying material.
The following chapters are good jumping-off points for beginners:</p>
<ul>
<li><a href="tutorials/tile-based-game/index.html"><em>Tile-based Game</em> tutorial</a></li>
<li><a href="explanation/level-selection.html"><em>Level Selection</em> explanation</a></li>
<li><a href="explanation/game-logic-integration.html"><em>Game Logic Integration</em> explanation</a></li>
</ul>
<h2 id="other-resources"><a class="header" href="#other-resources">Other resources</a></h2>
<p>This book is not suitable documentation for bevy or LDtk.
Some resources for learning Bevy include those listed on the <a href="https://bevyengine.org/learn">Bevy website</a>, as well as the unofficial <a href="https://bevy-cheatbook.github.io/">Bevy Cheat Book</a>.
LDtk also provides documentation on <a href="https://ldtk.io/docs/">its website</a>.</p>
<p><code>bevy_ecs_ldtk</code>'s <a href="https://github.com/Trouv/bevy_ecs_ldtk">source code</a> is available on github.
This repository also contains <a href="https://github.com/Trouv/bevy_ecs_ldtk/tree/v0.10.0/examples">cargo examples</a>, which can be run after cloning the repository using <code>$ cargo run --example example-name</code>. <!-- x-release-please-version -->
These examples may be difficult to follow on their own, and many of their strategies are described in this book.
When viewing these examples, be careful to checkout the correct git tag for the version of the plugin you are using.
Some changes may have been made to the plugin or to the examples on the <code>main</code> branch that are not released yet, and trying to apply these to the version of the plugin you are using can lead to errors.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>The pages of this book fall under the same license as the rest of the <code>bevy_ecs_ldtk</code> repository.
I.e., this book is dual-licensed under <a href="http://opensource.org/licenses/MIT">MIT</a> and <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache 2.0</a> at your option.
The plain text of this license is available in the <code>bevy_ecs_ldtk</code> repository's <a href="https://github.com/Trouv/bevy_ecs_ldtk/blob/main/LICENSE">LICENSE file</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tile-based-game"><a class="header" href="#tile-based-game">Tile-based Game</a></h1>
<p>In this tutorial you will make a tile-based game with LDtk levels.
Game entities will be locked to a grid of tiles like sokoban, or snake.
You will go through the process of creating an LDtk project, loading the project into bevy, and adding gameplay.</p>
<p>This tutorial does have an example associated with it in the <a href="https://github.com/trouv/bevy_ecs_ldtk"><code>bevy_ecs_ldtk</code> repository</a>:</p>
<pre><code class="language-bash">$ cargo run --example tile_based_game --release
</code></pre>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>You will need to perform the following setup/installations:</p>
<ul>
<li><a href="https://bevyengine.org/learn/book/getting-started/setup/">Bevy project setup</a> for the version specified in the <a href="https://github.com/Trouv/bevy_ecs_ldtk#compatibility">compatibility chart</a>.</li>
<li><a href="https://ldtk.io/versions/">LDtk installation</a>, for the version specified in the <a href="https://github.com/Trouv/bevy_ecs_ldtk#compatibility">compatibility chart</a>.</li>
</ul>
<p>You will also need some simple assets:</p>
<ul>
<li>A tileset for the environment with at least a background tile, a wall tile, and a &quot;goal&quot;-ish tile.</li>
<li>A tileset for the the player.</li>
</ul>
<p>For these purposes this tutorial will use the <code>environment/tileset.png</code> and <code>spritesheets/player.png</code> assets respectively from <a href="https://ansimuz.itch.io/sunny-land-pixel-game-art">SunnyLand by Ansimuz</a>, licensed under <a href="https://creativecommons.org/publicdomain/zero/1.0/">CC0 1.0</a>.
However, you will be able to follow this tutorial using any tilesets, so long as they have tiles appropriate for the above purposes.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-your-ldtk-project"><a class="header" href="#create-your-ldtk-project">Create your LDtk project</a></h1>
<p>In this section, you will create a simple LDtk project suitable for tile-based gameplay.
This project will have an IntGrid layer of walls, and an Entity layer for placing Player and Goal entities.
It will also have AutoTile rules on top of the IntGrid layer defining the visuals of walls and backgrounds.
If you already have an LDtk project suitable for tile-based gameplay - feel free to skip this section.
However, note that some of the values specified in here will be used in the tutorial going forward, such as...</p>
<ul>
<li>the name/location of the file (<code>assets/tile-based-game.ldtk</code>)</li>
<li>the identifiers of the Player and Goal entities (Player, Goal)</li>
<li>the IntGrid value of walls (1)</li>
</ul>
<p>For details about the tutorial in general, including prerequisites, please see the parent page.</p>
<h2 id="create-empty-project"><a class="header" href="#create-empty-project">Create empty project</a></h2>
<p>Open the LDtk app and create a new project.
For this tutorial, name the project <code>tile-based-game.ldtk</code>, and save it to your Bevy project's <code>assets</code> directory.</p>
<h2 id="set-the-world-layout"><a class="header" href="#set-the-world-layout">Set the World layout</a></h2>
<p>In the <strong>World</strong> tab - set the <strong>World layout</strong> to Horizontal.
This will make levels have a clear linear relationship in the editor, rather than a geographical one.</p>
<p><img src="tutorials/tile-based-game/images/world-layout.png" alt="world-layout" /></p>
<h2 id="import-tilesets"><a class="header" href="#import-tilesets">Import tilesets</a></h2>
<p>Add your environment/player tilesets to the project, in the <strong>Tilesets</strong> tab.
Make sure that the source image files for these tilesets are also in your Bevy project's <code>assets</code> directory.
Name the tilesets &quot;Environment&quot; and &quot;Player&quot; respectively.
For the SunnyLand assets - the Player tileset needs to have a tile size of 32 and the environment asset a tile size of 16.</p>
<p><img src="tutorials/tile-based-game/images/tilesets.png" alt="tilesets" /></p>
<h2 id="add-intgrid-layer-for-walls"><a class="header" href="#add-intgrid-layer-for-walls">Add IntGrid layer for walls</a></h2>
<p>Add an IntGrid layer to the project, in the <strong>Layers</strong> tab.
This layer will be used to define where the collisions are in the level.
Call this layer &quot;Walls&quot;.
Make sure its grid size is 16.
Finally, give it an <strong>Auto-layer tileset</strong> - pointing to the Environment tileset.</p>
<p><img src="tutorials/tile-based-game/images/wall-layer.png" alt="wall-layer" /></p>
<h2 id="define-autotiling-for-walls-and-backgrounds"><a class="header" href="#define-autotiling-for-walls-and-backgrounds">Define autotiling for walls and backgrounds</a></h2>
<p>From the Walls layer definition, select <strong>EDIT RULES</strong> for the Auto-layer tileset.
This is where you will define how LDtk should dynamically render the Walls layer of your levels based off the level's IntGrid values.</p>
<p>First, define a catch-all rule that will place the background tile if no other rules are matched first.</p>
<ol>
<li>Select <strong>+ GROUP</strong> to add a new empty rule group, and name it Background.</li>
<li>On the new group, select <strong>+</strong> to define the first rule.</li>
<li>In the top-right of the rule definition - select the tile you want to use as the background.</li>
<li>Since this is a catch-all rule, no changes to the rule-pattern are necessary.</li>
</ol>
<p><img src="tutorials/tile-based-game/images/background-rule.png" alt="background-rule" /></p>
<p>Next, define a rule that will catch any wall tile.
You will be able to define more complex rules on top of this to make walls prettier, but it's good to start with a generic one first.</p>
<ol>
<li>Create another new group, and name it Walls.</li>
<li>Click <strong>+</strong> on the Walls group to create its first rule.</li>
<li>Select the tile you want to use as a generic wall tile in the top-right.</li>
<li>Set the rule to be 1x1, and left-click the rule-pattern to place a wall tile.</li>
</ol>
<p><img src="tutorials/tile-based-game/images/all-walls-rule.png" alt="all-walls-rule" /></p>
<p>Now you will be able to place walls in your level and they will be automatically rendered using this tile.</p>
<p>The following rule is optional, and will define the tile used for the edges of walls - specifically horizontal edges.</p>
<ol>
<li>Create a new rule in the Walls group.</li>
<li>Select the tile you want to use as the left edges of a wall.</li>
<li>Use a 3x3 pattern, and place a wall tile in the center and a negative wall tile on the left (by right clicking the left-center tile).
This will match any wall tiles that don't have a wall tile to their left.</li>
<li>On this new rule inside the group, enable the <strong>X</strong> option.
This mirrors the rule in the x-direction, so that it works for the right edges of walls as well.</li>
</ol>
<p><img src="tutorials/tile-based-game/images/horizontal-wall-edge-rule.png" alt="horizontal-wall-edge-rule" /></p>
<p>You are welcome to add more rules to the Walls group with more complex patterns for defining the vertical edges or corners.
This tutorial will not go into painstaking detail about creating these, but their definitions are shown below.
One general recommendation is to order these rules from most-specific to least-specific, so that the rule matcher will resort to the catch-all rules last.</p>
<p>A vertical wall edge rule - mirrored in the <strong>Y</strong> direction:</p>
<p><img src="tutorials/tile-based-game/images/vertical-wall-edge-rule.png" alt="vertical-wall-edge-rule" /></p>
<p>An outer corner wall rule - mirrored in the <strong>X</strong> and <strong>Y</strong> directions:</p>
<p><img src="tutorials/tile-based-game/images/wall-outer-corner-rule.png" alt="wall-outer-corner-rule" /></p>
<p>An inner corner wall rule - mirrored in the <strong>X</strong> and <strong>Y</strong> directions:</p>
<p><img src="tutorials/tile-based-game/images/wall-inner-corner-rule.png" alt="wall-inner-corner-rule" /></p>
<p>Now you can enjoy placing walls in your level and watching LDtk auto-tile them for you!</p>
<div style="width:100%;height:0px;position:relative;padding-bottom:54.449%;"><iframe src="https://streamable.com/e/6v4pou" frameborder="0" width="100%" height="100%" allowfullscreen style="width:100%;height:100%;position:absolute;left:0px;top:0px;overflow:hidden;"></iframe></div>
<h2 id="add-entity-layer"><a class="header" href="#add-entity-layer">Add Entity layer</a></h2>
<p>Add an Entity layer to the project, again, in the <strong>Layers</strong> tab.
This will be used to place less tiling-oriented game objects, like the player, or the goal.
You do not need to make any modifications to the default entity layer for this tutorial, it should be called &quot;Entities&quot; and match the grid size of the Walls layer.</p>
<p><img src="tutorials/tile-based-game/images/entities-layer.png" alt="entity-layer" /></p>
<p>Then, in the <strong>Entities</strong> tab, add a Player entity.
Be sure to name it &quot;Player&quot; and set its editor visual to use a tile from the Player tileset.
This will be important in the next section of the tutorial.
For the SunnyLand assets - you will need to manually set its size to 16x16 so that it fits in a single tile on the grid.</p>
<p><img src="tutorials/tile-based-game/images/player-entity.png" alt="player-entity" /></p>
<p>Lastly, add a Goal entity.
Name it &quot;Goal&quot; and set its editor visual from a tileset as well.
Again, this will be important in the next section of the tutorial.</p>
<p><img src="tutorials/tile-based-game/images/goal-entity.png" alt="goal-entity" /></p>
<h2 id="design-some-levels"><a class="header" href="#design-some-levels">Design some levels</a></h2>
<p>In the following chapters, you will spawn this project in Bevy and implement gameplay code for it.
The game will be simple - move the player around the grid, navigating the walls, and start the next level once they reach the goal.
With this in mind, design a few levels for this game using the tools you have set up thus far.</p>
<p><img src="tutorials/tile-based-game/images/levels.png" alt="levels" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="spawn-your-ldtk-project-in-bevy"><a class="header" href="#spawn-your-ldtk-project-in-bevy">Spawn your LDtk project in Bevy</a></h1>
<p>In this section, you will load/spawn your LDtk project in Bevy, including spawning sprites for the LDtk entities.
This tutorial will use the LDtk project created in the previous section.
You are welcome to bring your own tile-based LDtk project to this tutorial, but some of the values specified in here are specific to the previous section, such as...</p>
<ul>
<li>the name/location of the file (<code>assets/tile-based-game.ldtk</code>)</li>
<li>the identifiers of the Player and Goal entities (Player, Goal)</li>
</ul>
<p>For details about the tutorial in general, including prerequisites, please see the parent page.</p>
<h2 id="set-up-minimal-bevy-app"><a class="header" href="#set-up-minimal-bevy-app">Set up minimal Bevy App</a></h2>
<p>In the <code>main</code> function of your game, create a Bevy <code>App</code> with <code>DefaultPlugins</code> and <code>LdtkPlugin</code>.
This code snippet also sets bevy's texture filtering to &quot;nearest&quot;, which is good for pixelated games.</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_ldtk::prelude::*;

fn main() {
    App::new()
        .add_plugins(DefaultPlugins.set(ImagePlugin::default_nearest()))
        .add_plugins(LdtkPlugin)
        .run();
}</code></pre></pre>
<h2 id="spawn-the-camera-and-ldtkworldbundle-on-startup"><a class="header" href="#spawn-the-camera-and-ldtkworldbundle-on-startup">Spawn the camera and LdtkWorldBundle on startup</a></h2>
<p>Create a startup system that spawns a camera entity and a <code>LdtkWorldBundle</code> entity.
The latter requires a <code>Handle&lt;LdtkProject&gt;</code>, which can be obtained by loading your LDtk project from the Bevy <code>AssetServer</code> resource.
This code snippet also doubles the scale of the camera and adjusts its transform to make the level slightly easier to view in 720p.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>fn main() {
    App::new()
        // other App builders
        .add_systems(Startup, setup)
        .run();
}

fn setup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {
    let mut camera = Camera2dBundle::default();
    camera.projection.scale = 0.5;
    camera.transform.translation.x += 1280.0 / 4.0;
    camera.transform.translation.y += 720.0 / 4.0;
    commands.spawn(camera);

    commands.spawn(LdtkWorldBundle {
        ldtk_handle: asset_server.load(&quot;tile-based-game.ldtk&quot;),
        ..Default::default()
    });
}</code></pre></pre>
<p>Finally, insert the <code>LevelSelection</code> resource to tell the plugin to spawn the first level.
Construct the <code>LevelSelection</code> using its <code>index</code> method to select the first level (0-indexed).</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>fn main() {
    App::new()
        // other App builders
        .insert_resource(LevelSelection::index(0))
        .run();
}</code></pre></pre>
<p>Now, run the game with <code>$ cargo run --release</code> to see your first level spawning in Bevy!</p>
<p><img src="tutorials/tile-based-game/images/bevy-setup.png" alt="bevy-setup" /></p>
<h2 id="spawn-sprites-for-your-ldtk-entities"><a class="header" href="#spawn-sprites-for-your-ldtk-entities">Spawn sprites for your LDtk entities</a></h2>
<p>You may have noticed that the Player and Goal are not rendered here.
They are there, but they require a little more work to become visible.</p>
<p>Create a <code>PlayerBundle</code> and <code>GoalBundle</code>, each with an <code>LdtkSpriteSheetBundle</code> field.
You will develop these bundles a little bit more in the next chapter, but for now they will be similar.
Derive <code>LdtkEntity</code> for these bundles, and give the field a <code>#[sprite_sheet_bundle]</code> attribute.
This trait implementation defines how these bundles should be spawned by the plugin.
More specifically - they should be spawned as sprites identical to the entity's editor visual.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>#[derive(Default, Bundle, LdtkEntity)]
struct PlayerBundle {
    #[sprite_sheet_bundle]
    sprite_sheet_bundle: LdtkSpriteSheetBundle,
}

#[derive(Default, Bundle, LdtkEntity)]
struct GoalBundle {
    #[sprite_sheet_bundle]
    sprite_sheet_bundle: LdtkSpriteSheetBundle,
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, register these bundles to the app using <code>register_ldtk_entity</code>, and provide their LDtk identifier.
When the plugin spawns entities with these identifiers, it will use the registered bundle.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>fn main() {
    App::new()
        // other App builders
        .register_ldtk_entity::&lt;PlayerBundle&gt;(&quot;Player&quot;)
        .register_ldtk_entity::&lt;GoalBundle&gt;(&quot;Goal&quot;)
        .run();
}
<span class="boring">#[derive(Default, Bundle, LdtkEntity)]
</span><span class="boring">struct PlayerBundle {
</span><span class="boring">    #[sprite_sheet_bundle]
</span><span class="boring">    sprite_sheet_bundle: LdtkSpriteSheetBundle,
</span><span class="boring">}
</span><span class="boring">#[derive(Default, Bundle, LdtkEntity)]
</span><span class="boring">struct GoalBundle {
</span><span class="boring">    #[sprite_sheet_bundle]
</span><span class="boring">    sprite_sheet_bundle: LdtkSpriteSheetBundle,
</span><span class="boring">}</span></code></pre></pre>
<p>Now run the game again - the sprites will appear this time.</p>
<p><img src="tutorials/tile-based-game/images/bevy-sprites.png" alt="bevy-sprites" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="add-gameplay-to-your-project"><a class="header" href="#add-gameplay-to-your-project">Add gameplay to your project</a></h1>
<p>In this section, you will integrate gameplay to the Bevy/LDtk project created in the previous sections.
This includes tile-based movement, collision, and level transitions.
You are welcome to bring your own tile-based LDtk project to this tutorial, but some of the values specified in here are specific to the LDtk project created in this tutorial, such as...</p>
<ul>
<li>the IntGrid value of walls (1)</li>
</ul>
<p>For details about the tutorial in general, including prerequisites, please see the parent page.</p>
<h2 id="add-marker-component-and-gridcoords-to-the-player"><a class="header" href="#add-marker-component-and-gridcoords-to-the-player">Add marker component and <code>GridCoords</code> to the player</a></h2>
<p>In order to implement tile-based movement and tile-based mechanics, you'll need to deal with an entity's position in tile-space rather than just Bevy world translation.
<code>bevy_ecs_ldtk</code> provides a component that is suitable for this, and it has integration with the <code>LdtkEntity</code> derive.
Add the <code>GridCoords</code> component to the <code>PlayerBundle</code>, and give it the <code>#[grid_coords]</code> attribute.
The player entity will then be spawned with a <code>GridCoords</code> component whose value matches the entity's position in grid-space.</p>
<p>Also give it a <code>Player</code> marker component so that you can query for it more easily in future systems.
Derive <code>Default</code> for this component.
<code>bevy_ecs_ldtk</code> will use this default implementation when spawning the component unless otherwise specified.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>#[derive(Default, Component)]
struct Player;

#[derive(Default, Bundle, LdtkEntity)]
struct PlayerBundle {
    player: Player,
    #[sprite_sheet_bundle]
    sprite_bundle: LdtkSpriteSheetBundle,
    #[grid_coords]
    grid_coords: GridCoords,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implement-tile-based-movement"><a class="header" href="#implement-tile-based-movement">Implement tile-based movement</a></h2>
<p>The player now has the components you will need to implement tile-based movement.
Write a system that checks for just-pressed WASD input and converts it to a <code>GridCoords</code> direction.
I.e., <code>(0,1)</code> for W, <code>(-1,0)</code> for A, <code>(0,-1)</code> for S, and <code>(1,0)</code> for D.
Then, add the new direction to the player entity's <code>GridCoords</code> component.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Player;
</span>fn main() {
    App::new()
        // other App builders
        .add_systems(Update, move_player_from_input)
        .run();
}

fn move_player_from_input(
    mut players: Query&lt;&amp;mut GridCoords, With&lt;Player&gt;&gt;,
    input: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
) {
    let movement_direction = if input.just_pressed(KeyCode::KeyW) {
        GridCoords::new(0, 1)
    } else if input.just_pressed(KeyCode::KeyA) {
        GridCoords::new(-1, 0)
    } else if input.just_pressed(KeyCode::KeyS) {
        GridCoords::new(0, -1)
    } else if input.just_pressed(KeyCode::KeyD) {
        GridCoords::new(1, 0)
    } else {
        return;
    };

    for mut player_grid_coords in players.iter_mut() {
        let destination = *player_grid_coords + movement_direction;
        *player_grid_coords = destination;
    }
}</code></pre></pre>
<h2 id="update-translation-from-gridcoords-value"><a class="header" href="#update-translation-from-gridcoords-value">Update translation from <code>GridCoords</code> value</a></h2>
<p>If you play the game at this point, you'll notice that the player entity doesn't appear to be moving at all.
The <code>GridCoords</code> component may be updating correctly, but the entity's <code>Transform</code> is what determines where it is rendered.
<code>bevy_ecs_ldtk</code> does not maintain the <code>Transform</code> of <code>GridCoords</code> entities automatically.
This is left up to the user, which allows you to implement custom tweening or animation of the transform as you please.</p>
<p>Write a system that updates the <code>Transform</code> of <code>GridCoords</code> entities when their <code>GridCoords</code> value changes.
<code>bevy_ecs_ldtk</code> does provide a utility function to help calculate the resulting translation - provided you know the size of the cells of the grid.
For the LDtk project set up in this tutorial using the <code>SunnyLand</code> tilesets, this grid size is 16.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">fn move_player_from_input() {}
</span>fn main() {
    App::new()
        // other App builders
        .add_systems(
            Update,
            (
                move_player_from_input,
                translate_grid_coords_entities,
            ),
        )
        .run();
}

const GRID_SIZE: i32 = 16;

fn translate_grid_coords_entities(
    mut grid_coords_entities: Query&lt;(&amp;mut Transform, &amp;GridCoords), Changed&lt;GridCoords&gt;&gt;,
) {
    for (mut transform, grid_coords) in grid_coords_entities.iter_mut() {
        transform.translation =
            bevy_ecs_ldtk::utils::grid_coords_to_translation(*grid_coords, IVec2::splat(GRID_SIZE))
                .extend(transform.translation.z);
    }
}</code></pre></pre>
<h2 id="prevent-tile-based-movement-into-walls"><a class="header" href="#prevent-tile-based-movement-into-walls">Prevent tile-based movement into walls</a></h2>
<p>Movement works logically <em>and</em> visually now.
However, you might notice that you can move <em>into</em> the walls of the level.
To implement tile-based collision, you will need to add components to the walls to identify their locations, and check against these locations when trying to move the player.</p>
<p>Create a new bundle for the wall entities, and give them a marker component.
Derive <code>LdtkIntCell</code> for this bundle, and register it to the app with <code>register_ldtk_int_cell</code> and the wall's intgrid value.
This bundle actually only needs this one marker component - IntGrid entities spawn with a <code>GridCoords</code> without requesting it.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>fn main() {
    App::new()
        // other App builders
        .register_ldtk_int_cell::&lt;WallBundle&gt;(1)
        .run();
}

#[derive(Default, Component)]
struct Wall;

#[derive(Default, Bundle, LdtkIntCell)]
struct WallBundle {
    wall: Wall,
}</code></pre></pre>
<p>There are a lot of ways to go about implementing the collision systems.
Naively, you could query for all of the <code>Wall</code> entities every time the player tries to move and check their <code>GridCoords</code> values.
In this tutorial, you will implement something a little more optimized: caching the wall locations into a resource when levels spawn.</p>
<p>Create a <code>LevelWalls</code> resource for storing the current wall locations that can be looked up by-value.
Give it a <code>HashSet&lt;GridCoords&gt;</code> field for the wall locations.
Give it fields for the level's width and height as well so you can prevent the player from moving out-of-bounds.
Then, implement a method <code>fn in_wall(&amp;self, grid_coords: &amp;GridCoords) -&gt; bool</code> that returns true if the provided <code>grid_coords</code> is outside the level bounds or contained in the <code>HashSet</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>use std::collections::HashSet;

fn main() {
    App::new()
        // other App builders
        .init_resource::&lt;LevelWalls&gt;()
        .run();
}

#[derive(Default, Resource)]
struct LevelWalls {
    wall_locations: HashSet&lt;GridCoords&gt;,
    level_width: i32,
    level_height: i32,
}

impl LevelWalls {
    fn in_wall(&amp;self, grid_coords: &amp;GridCoords) -&gt; bool {
        grid_coords.x &lt; 0
            || grid_coords.y &lt; 0
            || grid_coords.x &gt;= self.level_width
            || grid_coords.y &gt;= self.level_height
            || self.wall_locations.contains(grid_coords)
    }
}</code></pre></pre>
<p>Now, add a system that listens for <code>LevelEvent::Spawned</code> and populates this resource.
It will need access to all of the wall locations to populate the <code>HashSet</code> (<code>Query&lt;&amp;GridCoords, With&lt;Wall&gt;&gt;</code>).
It will also need access to the <code>LdtkProject</code> data to find the current level's width/height (<code>Query&lt;&amp;Handle&lt;LdtkProject&gt;&gt;</code> and <code>Res&lt;Assets&lt;LdtkProject&gt;&gt;</code>).</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">const GRID_SIZE: i32 = 16;
</span><span class="boring">#[derive(Default, Resource)]
</span><span class="boring">struct LevelWalls {
</span><span class="boring">    wall_locations: HashSet&lt;GridCoords&gt;,
</span><span class="boring">    level_width: i32,
</span><span class="boring">    level_height: i32,
</span><span class="boring">}
</span><span class="boring">impl LevelWalls {
</span><span class="boring">    fn in_wall(&amp;self, grid_coords: &amp;GridCoords) -&gt; bool {
</span><span class="boring">        grid_coords.x &lt; 0
</span><span class="boring">            || grid_coords.y &lt; 0
</span><span class="boring">            || grid_coords.x &gt;= self.level_width
</span><span class="boring">            || grid_coords.y &gt;= self.level_height
</span><span class="boring">            || self.wall_locations.contains(grid_coords)
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Wall;
</span><span class="boring">fn move_player_from_input() {}
</span><span class="boring">fn translate_grid_coords_entities() {}
</span>fn main() {
    App::new()
        // other App builders
        .add_systems(
            Update,
            (
                move_player_from_input,
                translate_grid_coords_entities,
                cache_wall_locations,
            )
        )
        .run();
}

fn cache_wall_locations(
    mut level_walls: ResMut&lt;LevelWalls&gt;,
    mut level_events: EventReader&lt;LevelEvent&gt;,
    walls: Query&lt;&amp;GridCoords, With&lt;Wall&gt;&gt;,
    ldtk_project_entities: Query&lt;&amp;Handle&lt;LdtkProject&gt;&gt;,
    ldtk_project_assets: Res&lt;Assets&lt;LdtkProject&gt;&gt;,
) {
    for level_event in level_events.read() {
        if let LevelEvent::Spawned(level_iid) = level_event {
            let ldtk_project = ldtk_project_assets
                .get(ldtk_project_entities.single())
                .expect(&quot;LdtkProject should be loaded when level is spawned&quot;);
            let level = ldtk_project
                .get_raw_level_by_iid(level_iid.get())
                .expect(&quot;spawned level should exist in project&quot;);

            let wall_locations = walls.iter().copied().collect();

            let new_level_walls = LevelWalls {
                wall_locations,
                level_width: level.px_wid / GRID_SIZE,
                level_height: level.px_hei / GRID_SIZE,
            };

            *level_walls = new_level_walls;
        }
    }
}</code></pre></pre>
<p>Finally, update the <code>move_player_from_input</code> system to access the <code>LevelWalls</code> resource and check whether or not the player's destination is in a wall.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">use std::collections::HashSet;
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Player;
</span><span class="boring">#[derive(Default, Resource)]
</span><span class="boring">struct LevelWalls {
</span><span class="boring">    wall_locations: HashSet&lt;GridCoords&gt;,
</span><span class="boring">    level_width: i32,
</span><span class="boring">    level_height: i32,
</span><span class="boring">}
</span><span class="boring">impl LevelWalls {
</span><span class="boring">    fn in_wall(&amp;self, grid_coords: &amp;GridCoords) -&gt; bool {
</span><span class="boring">        grid_coords.x &lt; 0
</span><span class="boring">            || grid_coords.y &lt; 0
</span><span class="boring">            || grid_coords.x &gt;= self.level_width
</span><span class="boring">            || grid_coords.y &gt;= self.level_height
</span><span class="boring">            || self.wall_locations.contains(grid_coords)
</span><span class="boring">    }
</span><span class="boring">}
</span>fn move_player_from_input(
    mut players: Query&lt;&amp;mut GridCoords, With&lt;Player&gt;&gt;,
    input: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
    level_walls: Res&lt;LevelWalls&gt;,
) {
    let movement_direction = if input.just_pressed(KeyCode::KeyW) {
        GridCoords::new(0, 1)
    } else if input.just_pressed(KeyCode::KeyA) {
        GridCoords::new(-1, 0)
    } else if input.just_pressed(KeyCode::KeyS) {
        GridCoords::new(0, -1)
    } else if input.just_pressed(KeyCode::KeyD) {
        GridCoords::new(1, 0)
    } else {
        return;
    };

    for mut player_grid_coords in players.iter_mut() {
        let destination = *player_grid_coords + movement_direction;
        if !level_walls.in_wall(&amp;destination) {
            *player_grid_coords = destination;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>With this check in place, the player should now be unable to move into walls!</p>
<h2 id="trigger-level-transitions-on-victory"><a class="header" href="#trigger-level-transitions-on-victory">Trigger level transitions on victory</a></h2>
<p>The final step is to implement the goal functionality.
When the player reaches the goal, the next level should spawn until there are no levels remaining.</p>
<p>Similar to the <code>PlayerBundle</code>, give the <code>GoalBundle</code> its own marker component and <code>GridCoords</code>.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>#[derive(Default, Component)]
struct Goal;

#[derive(Default, Bundle, LdtkEntity)]
struct GoalBundle {
    goal: Goal,
    #[sprite_sheet_bundle]
    sprite_bundle: LdtkSpriteSheetBundle,
    #[grid_coords]
    grid_coords: GridCoords,
}
<span class="boring">}</span></code></pre></pre>
<p>Then, write a system that checks if the player's <code>GridCoords</code> and the goal's <code>GridCoords</code> match.
For a small optimization, filter the player query for <code>Changed&lt;GridCoords&gt;</code> so it's only populated if the player moves.
If they do match, update the <code>LevelSelection</code> resource, increasing its level index by 1.
<code>bevy_ecs_ldtk</code> will automatically despawn the current level and spawn the next one when this resource is updated.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Player;
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Goal;
</span><span class="boring">fn move_player_from_input() {}
</span><span class="boring">fn translate_grid_coords_entities() {}
</span><span class="boring">fn cache_wall_locations() {}
</span>fn main() {
    App::new()
        // other App builders
        .add_systems(
            Update,
            (
                move_player_from_input,
                translate_grid_coords_entities,
                cache_wall_locations,
                check_goal,
            ),
        )
        .run();
}

fn check_goal(
    level_selection: ResMut&lt;LevelSelection&gt;,
    players: Query&lt;&amp;GridCoords, (With&lt;Player&gt;, Changed&lt;GridCoords&gt;)&gt;,
    goals: Query&lt;&amp;GridCoords, With&lt;Goal&gt;&gt;,
) {
    if players
        .iter()
        .zip(goals.iter())
        .any(|(player_grid_coords, goal_grid_coords)| player_grid_coords == goal_grid_coords)
    {
        let indices = match level_selection.into_inner() {
            LevelSelection::Indices(indices) =&gt; indices,
            _ =&gt; panic!(&quot;level selection should always be Indices in this game&quot;),
        };

        indices.level += 1;
    }
}</code></pre></pre>
<p>With this, the simple tile-based game is complete.
When you navigate the player to the goal, the next level will begin until there are no levels remaining.</p>
<div style="width:100%;height:0px;position:relative;padding-bottom:56.250%;"><iframe src="https://streamable.com/e/i342f8" frameborder="0" width="100%" height="100%" allowfullscreen style="width:100%;height:100%;position:absolute;left:0px;top:0px;overflow:hidden;"></iframe></div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="level-selection"><a class="header" href="#level-selection">Level Selection</a></h1>
<p>Once you have spawned an <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.LdtkWorldBundle.html"><code>LdtkWorldBundle</code></a> with a handle pointing to your LDtk project file, the levels you have selected will spawn as children of the world bundle. <!-- x-release-please-version -->
You have a couple options for selecting levels, which will be discussed in this chapter.</p>
<h2 id="levelselection-resource"><a class="header" href="#levelselection-resource"><code>LevelSelection</code> resource</a></h2>
<p>The highest-level option for selecting a level to spawn is using the <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/enum.LevelSelection.html"><code>LevelSelection</code></a> resource. <!-- x-release-please-version -->
This resource allows you to specify a particular level either by its indices in the project/world, its identifier, its iid, or its uid.
Once this resource is added or changed, levels will be spawned/despawned in order to match your selection.</p>
<p>One additional feature worth pointing out is loading level neighbors.
You can enable this with the settings resource <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.LdtkSettings.html"><code>LdtkSettings</code></a>: <!-- x-release-please-version --></p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_ldtk::prelude::*;

fn main() {
    App::new()
        // other App builders
        .insert_resource(LevelSelection::index(0))
        .insert_resource(LdtkSettings {
            level_spawn_behavior: LevelSpawnBehavior::UseWorldTranslation {
                load_level_neighbors: true
            },
            ..default()
        })
        .run();
}</code></pre></pre>
<p>With this set, the plugin will spawn the currently-selected level's neighbors in addition to the currently-selected level.
This can be especially useful for GridVania/Free-style worlds where it's important to have a level spawned before the player traverses to it.
Note: this <em>only</em> works if you are using the <code>LevelSelection</code> resource.</p>
<h2 id="levelset-component"><a class="header" href="#levelset-component"><code>LevelSet</code> component</a></h2>
<p>One component in the <code>LdtkWorldBundle</code> is <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.LevelSet.html"><code>LevelSet</code></a>. <!-- x-release-please-version -->
This component can be used for lower-level level selection.
Instead of selecting one level globally with a <code>LevelSelection</code> resource, you can select a specific set of levels by their iids.
From the <code>level_set</code> cargo example:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>const LEVEL_IIDS: [&amp;str; 8] = [
    &quot;a3591db0-66b0-11ec-9cd7-43878cf4d0ab&quot;,
    &quot;a35944c0-66b0-11ec-9cd7-6b4e2322a69e&quot;,
    &quot;a35992e0-66b0-11ec-9cd7-8b2ebd1b98e2&quot;,
    &quot;a359b9f0-66b0-11ec-9cd7-25dfb937d033&quot;,
    &quot;a35a2f20-66b0-11ec-9cd7-db6f994e2834&quot;,
    &quot;a35aa451-66b0-11ec-9cd7-438de356526d&quot;,
    &quot;a35acb61-66b0-11ec-9cd7-f76e35cfda30&quot;,
    &quot;a35b8eb0-66b0-11ec-9cd7-3d16ec48af10&quot;,
];

fn setup(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {
    commands.spawn(Camera2dBundle::default());

    let level_set = LevelSet::from_iids(LEVEL_IIDS);

    commands.spawn(LdtkWorldBundle {
        ldtk_handle: asset_server.load(&quot;WorldMap_Free_layout.ldtk&quot;),
        level_set,
        transform: Transform::from_xyz(-256., -144., 0.),
        ..Default::default()
    });
}
<span class="boring">fn main() {}</span></code></pre></pre>
<p>This component is actually used by <code>LevelSelection</code> under the hood.
So, in order for this workflow to work properly, no <code>LevelSelection</code> resource can exist in the world.
This also implies, as mentioned in the previous section, that <code>load_level_neighbors</code> cannot be used with the <code>LevelSet</code> workflow.
However, the <code>LevelSpawnBehavior::UseWorldTranslation</code> option in general <em>does</em> work, and should be used if you plan to spawn multiple levels anyway.</p>
<p><code>LevelSet</code> is ideal for more complex level-spawning needs.
It is an option if you need any level-spawning behavior that <code>LevelSelection</code>/<code>load_level_neighbors</code> are not capable of.
Furthermore, if you have more than one <code>LdtkWorldBundle</code> spawned, it can be used to select different levels per-world, which is impossible with global level selection.</p>
<p>When the set of levels in the <code>LevelSet</code> is updated, an extra layer of change-detection is employed to make these changes idempotent/declarative.
In other words, the plugin will observe what levels are already spawned before trying to respond to the changes in <code>LevelSet</code>.
Only levels <em>in</em> the level set that <em>aren't</em> currently spawned will be spawned - and only levels <em>not in</em> the level set that <em>are</em> currently spawned will be despawned.
Everything else will be left alone, remaining spawned or despawned appropriately.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="game-logic-integration"><a class="header" href="#game-logic-integration">Game Logic Integration</a></h1>
<p>Loading LDtk levels into Bevy doesn't get you very far if you cannot play them.</p>
<p>Aside from rendering tilemaps, LDtk has features for placing gameplay objects on Entity layers.
Even within tilemaps, IntGrid layers imply a categorization of tiles, and perhaps a game designerly meaning.
It is fundamental to associate the LDtk entities and IntGrid tiles with Bevy entities/components.
<code>bevy_ecs_ldtk</code> is designed around a couple core strategies for doing so, which will be discussed here.</p>
<h2 id="ldtkentity-and-ldtkintcell-registration"><a class="header" href="#ldtkentity-and-ldtkintcell-registration"><code>LdtkEntity</code> and <code>LdtkIntCell</code> registration</a></h2>
<p>The <code>LdtkEntity</code>/<code>LdtkIntCell</code> registration API allows you to hook custom bevy <code>Bundle</code>s into the level spawning process.
You define what components you want on the entity with a bundle, define how they should be constructed with the <code>LdtkEntity</code> or <code>LdtkIntCell</code> derive, and register the bundle to the <code>App</code> for a given LDtk entity identifier, or IntGrid value.</p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_ldtk::prelude::*;

fn main() {
    App::new()
        // other App builders
        .register_ldtk_entity::&lt;PlayerBundle&gt;(&quot;Player&quot;)
        .run();
}

#[derive(Default, Component)]
struct Player;

#[derive(Default, Bundle, LdtkEntity)]
struct PlayerBundle {
    player: Player,
    #[sprite_bundle]
    sprite_bundle: SpriteBundle,
}</code></pre></pre>
<p>How does <code>LdtkEntity</code>/<code>LdtkIntCell</code> construct the bundle when derived?
Without any intervention, the bundle's fields are constructed using the bundle's <code>Default</code> implementation.
However, various attributes are available to override this behavior, like <code>#[sprite_bundle]</code> in the above example.
This attribute gives the entity a sprite using the tileset in its LDtk editor visual.
For documentation about all the available attributes, check out the API reference for these traits:</p>
<ul>
<li><a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/app/trait.LdtkEntity.html"><code>LdtkEntity</code></a> <!-- x-release-please-version --></li>
<li><a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/app/trait.LdtkIntCell.html"><code>LdtkIntCell</code></a> <!-- x-release-please-version --></li>
</ul>
<p>This approach is suitable for many common, simple use cases.
There's also room for more granular, component-level customization within some of the attributes, like <code>#[with(...)]</code> or <code>#[from_entity_instance]</code>.
Of course, the traits can also be manually implemented for the even-more-custom cases.</p>
<h2 id="post-processing-plugin-spawned-entities"><a class="header" href="#post-processing-plugin-spawned-entities">Post-processing plugin-spawned entities</a></h2>
<p>There are still many cases where <code>LdtkEntity</code>/<code>LdtkIntCell</code> registration is insufficient.
Perhaps you need to spawn children of the entity, or need access to more resources in the <code>World</code>.
For these more demanding cases, post-processing plugin-spawned entities in a custom system is always an option.</p>
<p>If an LDtk entity does not have a matching <code>LdtkEntity</code> registration, it will be spawned with an <code>EntityInstance</code> component by default.
This component contains the raw LDtk data for that entity.
Querying for newly-spawned <code>EntityInstance</code> entities can be a good starting point for implementing your own custom spawning logic.
Intgrid tiles have similar behavior, except their default component is <code>IntGridCell</code>, which simply contains the IntGrid value for that tile.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>#[derive(Default, Component)]
struct PlayerChild;

#[derive(Default, Component)]
struct Player;

fn process_player(
    mut commands: Commands,
    new_entity_instances: Query&lt;(Entity, &amp;EntityInstance, &amp;Transform), Added&lt;EntityInstance&gt;&gt;,
    assets: Res&lt;AssetServer&gt;,
)
{
    for (entity, entity_instance, transform) in new_entity_instances.iter() {
        if entity_instance.identifier == &quot;Player&quot;.to_string() {
            commands
                .entity(entity)
                .insert(Player)
                .insert(SpriteBundle {
                    texture: assets.load(&quot;player.png&quot;),
                    transform: *transform,
                    ..default()
                })
                .with_children(|commands| {
                    commands.spawn(PlayerChild);
                });
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This approach makes spawning entities from LDtk just as powerful and customizable as a Bevy system, because that's all it is.
<code>LdtkEntity</code> and <code>LdtkIntCell</code> ultimately make some assumptions about what data from the LDtk asset and the Bevy world you will need to spawn your entity, which post-processing avoids.
However, there are some pretty obvious ergonomics issues to this strategy compared to using registration:</p>
<ul>
<li>You need to manually filter <code>EntityInstance</code>s for the desired LDtk entity identifier.</li>
<li>You need to manually perform the iteration of the query.</li>
<li>You may need to manually find the associated layer data, or tileset image, or tileset definition (if necessary).</li>
<li>You need to be careful not to overwrite the plugin-provided <code>Transform</code> component.</li>
</ul>
<h2 id="a-combined-approach---the-blueprint-pattern"><a class="header" href="#a-combined-approach---the-blueprint-pattern">A combined approach - the blueprint pattern</a></h2>
<p>At least one of these ergonomics issues can be alleviated with a combined approach.
If you register an <code>LdtkEntity</code>/<code>LdtkIntCell</code> with a marker component, querying for it later won't require filtering for a particular entity instance identifier.
The plugin does that for you when giving the entity your bundle, then you can write queries that filter for the marker component instead of <code>EntityInstance</code> or <code>IntGridCell</code>.
Furthermore, if you can add the transform-overwriting bundles within the <code>LdtkEntity</code> bundle, you won't need to tiptoe around the <code>Transform</code> in your post-processing system.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>fn main() {
    App::new()
        // other App builders
        .register_ldtk_entity::&lt;PlayerBundle&gt;(&quot;Player&quot;)
        .add_systems(Update, process_player)
        .run();
}

#[derive(Default, Component)]
struct PlayerChild;

#[derive(Default, Component)]
struct Player;

#[derive(Default, Bundle, LdtkEntity)]
struct PlayerBundle {
    player: Player,
    #[sprite_bundle]
    sprite_bundle: SpriteBundle,
}

fn process_player(
    mut commands: Commands,
    new_players: Query&lt;Entity, Added&lt;Player&gt;&gt;,
)
{
    for player_entity in new_players.iter() {
        commands
            .spawn(PlayerChild)
            .set_parent(player_entity);
    }
}</code></pre></pre>
<p>Using a simple component or a marker component for the initial spawn of an entity and processing it further in another system is called the &quot;blueprint pattern&quot;.
You may find it desirable to use the <code>LdtkEntity</code>/<code>LdtkIntCell</code> derives to construct most of the components, but need post-processing for the more demanding ones.
This approach is recommended over filtering for <code>Added&lt;EntityInstance&gt;</code> or <code>Added&lt;IntGridCell&gt;</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anatomy-of-the-world"><a class="header" href="#anatomy-of-the-world">Anatomy of the World</a></h1>
<p>Once an <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.LdtkWorldBundle.html"><code>LdtkWorldBundle</code></a> is spawned, <a href="explanation/level-selection.html">levels are selected</a>, and the associated assets finish loading, the level spawning process begins. <!-- x-release-please-version -->
The result is a deeply nested hierarchy of entities which can be difficult to navigate, but predictable.
It can be useful to write code that makes assumptions about the relationships between <code>bevy_ecs_ldtk</code> entities.
To assist with this, this chapter will explain the anatomy of a <code>bevy_ecs_ldtk</code> world.</p>
<h2 id="hierarchy"><a class="header" href="#hierarchy">Hierarchy</a></h2>
<p>The basic hierarchy of spawned entities and their identifying components/bundles are as follows.
This does exclude some special cases which are explained in more detail below.
Each bullet indent indicates a parent/child relationship.</p>
<ul>
<li>The world entity, with an <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.LdtkWorldBundle.html"><code>LdtkWorldBundle</code></a> bundle. <!-- x-release-please-version -->
<ul>
<li>The level entities, with a <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.LevelIid.html"><code>LevelIid</code></a> component. <!-- x-release-please-version -->
<ul>
<li>For Entity layers - a layer entity with just a <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.LayerMetadata.html"><code>LayerMetadata</code></a> component. <!-- x-release-please-version -->
<ul>
<li>LDtk Entity entities, with an <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/ldtk/struct.EntityInstance.html"><code>EntityInstance</code></a> component, or possibly others if you're using <a href="explanation/game-logic-integration.html#ldtkentity-and-ldtkintcell-registration"><code>LdtkEntity</code> registration</a>. <!-- x-release-please-version --> </li>
</ul>
</li>
<li>For Tile/AutoTile/IntGrid layers: <code>bevy_ecs_tilemap</code> tilemap entities, with a <a href="https://docs.rs/bevy_ecs_tilemap/latest/bevy_ecs_tilemap/type.TilemapBundle.html"><code>TilemapBundle</code></a> <strong>and</strong> a <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.LayerMetadata.html"><code>LayerMetadata</code></a> component. <!-- x-release-please-version -->
<ul>
<li>For IntGrid layers - tile entities with an <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.IntGridCell.html"><code>IntGridCell</code></a> component, or possibly others if you're using <a href="explanation/game-logic-integration.html#ldtkentity-and-ldtkintcell-registration"><code>LdtkIntCell</code> registration</a>. <!-- x-release-please-version --></li>
<li>For Tile/AutoTile layers (or IntGrid layers with AutoTile functionality) - <code>bevy_ecs_tilemap</code> tile entities, with a <a href="https://docs.rs/bevy_ecs_tilemap/latest/bevy_ecs_tilemap/tiles/struct.TileBundle.html"><code>TileBundle</code></a> bundle.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="worldly-entities"><a class="header" href="#worldly-entities">Worldly Entities</a></h2>
<p>The <a href="explanation/game-logic-integration.html#ldtkentity-and-ldtkintcell-registration"><code>LdtkEntity</code> derive macro</a> allows you to define entities as <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/app/trait.LdtkEntity.html#worldly">&quot;worldly&quot;</a>. <!-- x-release-please-version -->
The intention of this feature is to support entities that are allowed to persist and traverse between levels, like a player in a GridVania layout.</p>
<p>One consequence of an entity being worldly is a change in its placement in the above hierarchy.
Instead of being spawned as a child of the Entity layer entity, worldly entities will be children of the world entity (after one update).
This makes the worldly entity independent of their origin level, so that if the origin level is unloaded, the worldly entity can still persist.</p>
<p>Furthermore, a worldly entity will <em>not</em> be spawned if it already exists.
This prevents two of the same worldly entity existing if the origin level is despawned and respawned.
For example, if the worldly player entity traverses far enough away that their origin level is unloaded, then returns to it, there won't suddenly be two players.</p>
<h2 id="tile-metadata-components"><a class="header" href="#tile-metadata-components">Tile metadata components</a></h2>
<p>LDtk allows you to associate metadata with particular tiles in a tileset.
<code>bevy_ecs_ldtk</code> responds to this by adding additional components to tiles that have metadata <em>in addition to</em> those described in the <a href="explanation/anatomy-of-the-world.html#hierarchy">hierarchy</a>:</p>
<ul>
<li><a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.TileMetadata.html"><code>TileMetadata</code></a> <!-- x-release-please-version --></li>
<li><a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.TileEnumTags.html"><code>TileEnumTags</code></a> <!-- x-release-please-version --></li>
</ul>
<p>Naturally, this can only occur in Tile/AutoTile layers (or IntGrid layers with AutoTile functionality), since the metadata is defined on tilesets.</p>
<h2 id="level-backgrounds"><a class="header" href="#level-backgrounds">Level backgrounds</a></h2>
<p>LDtk allows you to supply a background color and a background image for individual levels.
<code>bevy_ecs_ldtk</code> renders these by default.
The background color is spawned as a normal bevy <a href="https://docs.rs/bevy/latest/bevy/prelude/struct.SpriteBundle.html"><code>SpriteBundle</code></a>, as a child of the level entity.
The background image, if it exists, is also spawned as a <code>SpriteBundle</code>.</p>
<p>These background sprites can be disabled (not spawned) using the settings resource <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.LdtkSettings.html"><code>LdtkSettings</code></a>: <!-- x-release-please-version --></p>
<pre><pre class="playground"><code class="language-rust no_run">use bevy::prelude::*;
use bevy_ecs_ldtk::prelude::*;

fn main() {
    App::new()
        // other App builders
        .insert_resource(LdtkSettings {
            level_background: LevelBackground::Nonexistent,
            ..default()
        })
        .run();
}</code></pre></pre>
<h2 id="layers-with-colliding-tiles"><a class="header" href="#layers-with-colliding-tiles">Layers with colliding tiles</a></h2>
<p>It is possible for LDtk Tile/AutoTile layers to have colliding tiles.
In other words, a single layer can have more than one tile in the same location.</p>
<p><code>bevy_ecs_tilemap</code> tilemaps only allow one tile per position.
So, <code>bevy_ecs_ldtk</code> supports layers with colliding tiles by spawning multiple tilemaps.
Each of them will have the same <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.LayerMetadata.html"><code>LayerMetadata</code></a> component. <!-- x-release-please-version -->
This means that users cannot assume that there will be only one <code>LayerMetadata</code> entity per layer.</p>
<h2 id="z-order"><a class="header" href="#z-order">Z order</a></h2>
<p>To correctly define the render order of the tiles and entities in a level, <code>bevy_ecs_ldtk</code> uses the <code>z</code> value of their <code>Transform</code> components.
Z order is only applied to <a href="explanation/anatomy-of-the-world.html#level-backgrounds">level backgrounds</a>, <a href="explanation/anatomy-of-the-world.html#layers-with-colliding-tiles">layer entities</a>, and <a href="explanation/anatomy-of-the-world.html#worldly-entities">worldly entities</a>.
Tiles and non-worldly entities will simply inherit the z-ordering in their <code>GlobalTransform</code>.</p>
<p><code>bevy_ecs_ldtk</code> begins with a <code>z</code> value of 0 for the background-most entities, and increments this by 1 for each layer above that.
This sounds simple, but can actually be pretty difficult to predict thanks to some special cases mentioned above.</p>
<p><a href="explanation/anatomy-of-the-world.html#level-backgrounds">Background colors and background images</a> will usually get the <code>z</code> values of 0 and 1 respectively.
However, if the background image does not exist, the <code>z</code> value of 1 will be freed for the next layer instead.
If level backgrounds are disabled entirely, both 0 and 1 will be freed for the next layer.</p>
<p>From here, each layer generally increments the <code>z</code> value by 1.
However, note that <a href="explanation/anatomy-of-the-world.html#layers-with-colliding-tiles">there can be multiple layer entities for a single LDtk layer</a>.
Each of these additional layer entities will also increment the <code>z</code> value by 1.</p>
<p>Since this can be difficult to predict, it is generally recommended to avoid making assumptions about the <code>z</code> value of a layer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create-bevy-relations-from-ldtk-entity-references"><a class="header" href="#create-bevy-relations-from-ldtk-entity-references">Create Bevy Relations from LDtk Entity References</a></h1>
<p>LDtk allows entities to point to other entities using a field.
This is analogous to a bevy &quot;relation&quot; - a component on one entity that stores the <code>Entity</code> identifier of another entity.</p>
<p>This chapter goes through one possible method for resolving LDtk entity references as such.
This code is used in the <code>field_instances</code> cargo example, and facilitates &quot;enemy&quot; entities pointing to another &quot;enemy&quot; entity as their &quot;mother&quot;.</p>
<h2 id="register-unresolved-reference"><a class="header" href="#register-unresolved-reference">Register unresolved reference</a></h2>
<p>First, create a component representing an &quot;unresolved&quot; entity reference, storing the target entity's LDtk iid rather than a bevy <code>Entity</code>:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>#[derive(Debug, Default, Deref, DerefMut, Component)]
pub struct UnresolvedMotherRef(Option&lt;EntityIid&gt;);
<span class="boring">}</span></code></pre></pre>
<p>Create a method for constructing this component from an <code>&amp;EntityInstance</code>.
This should retrieve the value of the entity reference field instance on the LDtk entity.
Most likely, you'll use a hard-coded field identifier (&quot;mother&quot; in this example) to find it:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">pub struct UnresolvedMotherRef(Option&lt;EntityIid&gt;);
</span>impl UnresolvedMotherRef {
    pub fn from_mother_field(entity_instance: &amp;EntityInstance) -&gt; UnresolvedMotherRef {
        UnresolvedMotherRef(
            entity_instance
                .get_maybe_entity_ref_field(&quot;mother&quot;)
                .expect(&quot;expected entity to have mother entity ref field&quot;)
                .as_ref()
                .map(|entity_ref| EntityIid::new(entity_ref.entity_iid.clone())),
        )
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Add this component to the <code>LdtkEntity</code> and configure it to be constructed using this method.
This guide assumes that you've already registered this bundle to the app.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">#[derive(Debug, Default, Deref, DerefMut, Component)]
</span><span class="boring">pub struct UnresolvedMotherRef(Option&lt;EntityIid&gt;);
</span><span class="boring">impl UnresolvedMotherRef { fn from_mother_field(_: &amp;EntityInstance) -&gt; UnresolvedMotherRef { todo!() } }
</span>#[derive(Default, Bundle, LdtkEntity)]
pub struct EnemyBundle {
    #[with(UnresolvedMotherRef::from_mother_field)]
    unresolved_mother: UnresolvedMotherRef,
    #[sprite_sheet_bundle]
    sprite_sheet_bundle: LdtkSpriteSheetBundle,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="resolve-reference-in-post-processing"><a class="header" href="#resolve-reference-in-post-processing">Resolve reference in post-processing</a></h2>
<p>Create a second relational component that stores the actual bevy <code>Entity</code> that this <code>Unresolved</code> reference should &quot;resolve&quot; to.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>#[derive(Debug, Deref, DerefMut, Component, Reflect)]
pub struct Mother(Entity);
<span class="boring">}</span></code></pre></pre>
<p>Finally, create a <a href="how-to-guides/../explanation/game-logic-integration.html#post-processing-plugin-spawned-entities">&quot;post-processing&quot;</a> system that takes entities with the <code>Unresolved</code> component, finds the entity with the matching <code>EntityIid</code>, and replaces the <code>Unresolved</code> component with the relational component.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">#[derive(Debug, Default, Deref, DerefMut, Component)]
</span><span class="boring">pub struct UnresolvedMotherRef(Option&lt;EntityIid&gt;);
</span><span class="boring">#[derive(Debug, Deref, DerefMut, Component, Reflect)]
</span><span class="boring">pub struct Mother(Entity);
</span>pub fn resolve_mother_references(
    mut commands: Commands,
    unresolved_mothers: Query&lt;(Entity, &amp;UnresolvedMotherRef), Added&lt;UnresolvedMotherRef&gt;&gt;,
    ldtk_entities: Query&lt;(Entity, &amp;EntityIid)&gt;,
) {
    for (child_entity, unresolved_mother_ref) in unresolved_mothers.iter() {
        if let Some(mother_iid) = unresolved_mother_ref.0.as_ref() {
            let (mother_entity, _) = ldtk_entities
                .iter()
                .find(|(_, iid)| *iid == mother_iid)
                .expect(&quot;enemy's mother entity should exist&quot;);

            commands
                .entity(child_entity)
                .remove::&lt;UnresolvedMotherRef&gt;()
                .insert(Mother(mother_entity));
        } else {
            commands
                .entity(child_entity)
                .remove::&lt;UnresolvedMotherRef&gt;();
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="respawn-levels-and-worlds"><a class="header" href="#respawn-levels-and-worlds">Respawn Levels and Worlds</a></h1>
<p>Internally, <code>bevy_ecs_ldtk</code> uses a <a href="https://docs.rs/bevy_ecs_ldtk/0.10.0/bevy_ecs_ldtk/prelude/struct.Respawn.html"><code>Respawn</code></a> component on worlds and levels to assist in the spawning process. <!-- x-release-please-version -->
This can be leveraged by users to implement a simple level restart feature, or an even more heavy-handed world restart feature.</p>
<p>This code is from the <code>collectathon</code> cargo example.</p>
<h2 id="respawn-the-world"><a class="header" href="#respawn-the-world">Respawn the world</a></h2>
<p>To respawn the world, get the world's <code>Entity</code> and insert the <code>Respawn</code> component to it.
This is especially easy if, like most users, you only have one world in your game.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>fn respawn_world(
    mut commands: Commands,
    ldtk_projects: Query&lt;Entity, With&lt;Handle&lt;LdtkProject&gt;&gt;&gt;,
    input: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
) {
    if input.just_pressed(KeyCode::KeyR) {
        commands.entity(ldtk_projects.single()).insert(Respawn);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that this <em>will</em> respawn <a href="how-to-guides/../explanation/anatomy-of-the-world.html#worldly-entities">worldly</a> entities too.</p>
<h2 id="respawn-the-currently-selected-level"><a class="header" href="#respawn-the-currently-selected-level">Respawn the currently-selected level</a></h2>
<p>Respawning a level works similarly to respawning the world.
Get the level's <code>Entity</code> and insert the <code>Respawn</code> component to it.</p>
<p>The optimal strategy for finding the level entity can differ depending on the game.
For example, if the game should only spawn one level at a time, operate under that assumption and query for the only <code>LevelIid</code> entity.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>fn respawn_only_level(
    mut commands: Commands,
    levels: Query&lt;Entity, With&lt;LevelIid&gt;&gt;,
    input: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;
) {
    if input.just_pressed(KeyCode::KeyL) {
        commands.entity(levels.single()).insert(Respawn);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If the game spawns multiple levels and you want the one specified in the <code>LevelSelection</code>, you may need a more complex strategy.</p>
<p>In the <code>collectathon</code> cargo example, the <code>LevelSelection</code> is always assumed to be of the <code>Iid</code> variety.
If you share this assumption, get the <code>LevelIid</code> from the <code>LevelSelection</code> and then search for the matching level entity.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>fn respawn_level(
    mut commands: Commands,
    level_selection: Res&lt;LevelSelection&gt;,
    levels: Query&lt;(Entity, &amp;LevelIid)&gt;,
    input: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
) {
    if input.just_pressed(KeyCode::KeyL) {
        let level_selection_iid = match level_selection.as_ref() {
            LevelSelection::Iid(iid) =&gt; iid,
            _ =&gt; panic!(&quot;level should always be selected by iid in this example&quot;),
        };

        for (level_entity, level_iid) in levels.iter() {
            if level_iid == level_selection_iid {
                commands.entity(level_entity).insert(Respawn);
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>However, if you cannot make the same assumption, access the <code>LdtkProject</code> asset data and search for the level matching your <code>LevelSelection</code>.
There is a method on <code>LdtkProject</code> to perform this search.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>fn respawn_level(
    mut commands: Commands,
    level_selection: Res&lt;LevelSelection&gt;,
    levels: Query&lt;(Entity, &amp;LevelIid)&gt;,
    input: Res&lt;ButtonInput&lt;KeyCode&gt;&gt;,
    ldtk_projects: Query&lt;&amp;Handle&lt;LdtkProject&gt;&gt;,
    ldtk_project_assets: Res&lt;Assets&lt;LdtkProject&gt;&gt;,
) {
    if input.just_pressed(KeyCode::KeyL) {
        if let Some(only_project) = ldtk_project_assets.get(ldtk_projects.single()) {
            let level_selection_iid = LevelIid::new(
                only_project
                    .find_raw_level_by_level_selection(&amp;level_selection)
                    .expect(&quot;spawned level should exist in project&quot;)
                    .iid
                    .clone(),
            );

            for (level_entity, level_iid) in levels.iter() {
                if level_selection_iid == *level_iid {
                    commands.entity(level_entity).insert(Respawn);
                }
            }

        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note that, unlike respawning the world, respawning the level will <em>not</em> respawn any <a href="how-to-guides/../explanation/anatomy-of-the-world.html#worldly-entities">worldly</a> entities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="make-levelselection-follow-player"><a class="header" href="#make-levelselection-follow-player">Make LevelSelection Follow Player</a></h1>
<p>In games with GridVania/Free world layouts, it is common to make the player <a href="how-to-guides/../explanation/anatomy-of-the-world.html#worldly-entities">&quot;worldly&quot;</a> and have them traverse levels freely.
This level traversal requires levels to be spawned as/before the Player traverses to them, and for levels to be despawned as the player traverses away from them.</p>
<p>This guide demonstrates one strategy for managing levels like this: having the <code>LevelSelection</code> follow the player entity.
This code comes from the <code>collectathon</code> cargo example.</p>
<h2 id="use-world-translation-for-levels-and-load-level-neighbors"><a class="header" href="#use-world-translation-for-levels-and-load-level-neighbors">Use world translation for levels and load level neighbors</a></h2>
<p>Rather than spawning a level the moment the player travels to them, this guide instead loads levels <em>before</em> they reach them.
Use the <a href="how-to-guides/../explanation/level-selection.html#levelselection-resource">&quot;load level neighbors&quot;</a> feature, so the plugin spawns not just the currently selected level, but its neighbors too.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>fn main() {
    App::new()
        // Other App builders
        .insert_resource(LdtkSettings {
            level_spawn_behavior: LevelSpawnBehavior::UseWorldTranslation {
                load_level_neighbors: true,
            },
            ..default()
        })
        .run();
}</code></pre></pre>
<h2 id="determine-bounds-of-spawned-levels-and-update-level-selection"><a class="header" href="#determine-bounds-of-spawned-levels-and-update-level-selection">Determine bounds of spawned levels and update level selection</a></h2>
<p>With <code>load_level_neighbors</code> enabled, any level that the player can traverse to will already be spawned, barring teleportation.
Use the transforms of the spawned levels and width/height info from the level's asset data to create a <code>Rect</code> of the level's bounds.</p>
<p>To access the level asset data, you first need to access the project asset data.
Assuming you only have one project, query for the only <code>Handle&lt;LdtkProject&gt;</code> entity and look up its asset data in the <code>LdtkProject</code> asset store.
Then, get the raw level data for every spawned level using the level entity's <code>LevelIid</code> component (there is a provided method for this).</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Player;
</span>fn level_selection_follow_player(
    players: Query&lt;&amp;GlobalTransform, With&lt;Player&gt;&gt;,
    levels: Query&lt;(&amp;LevelIid, &amp;GlobalTransform)&gt;,
    ldtk_projects: Query&lt;&amp;Handle&lt;LdtkProject&gt;&gt;,
    ldtk_project_assets: Res&lt;Assets&lt;LdtkProject&gt;&gt;,
    mut level_selection: ResMut&lt;LevelSelection&gt;,
) {
    if let Ok(player_transform) = players.get_single() {
        let ldtk_project = ldtk_project_assets
            .get(ldtk_projects.single())
            .expect(&quot;ldtk project should be loaded before player is spawned&quot;);

        for (level_iid, level_transform) in levels.iter() {
            let level = ldtk_project
                .get_raw_level_by_iid(level_iid.get())
                .expect(&quot;level should exist in only project&quot;);
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The level's <code>GlobalTransform</code>'s x/y value should be used as the lower-left bound of the <code>Rect</code>.
Add the raw level's <code>px_wid</code> and <code>pix_hei</code> values to the lower-left bound to calculate the upper-right bound.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::ldtk::Level;
</span><span class="boring">fn foo(level_transform: &amp;GlobalTransform, level: &amp;Level) {
</span>            let level_bounds = Rect {
                min: Vec2::new(
                    level_transform.translation().x,
                    level_transform.translation().y,
                ),
                max: Vec2::new(
                    level_transform.translation().x + level.px_wid as f32,
                    level_transform.translation().y + level.px_hei as f32,
                ),
            };
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>After creating a <code>Rect</code> of the level bounds, check if the player is inside those bounds and update the <code>LevelSelection</code> resource accordingly.
The full system should look something like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">#[derive(Component)]
</span><span class="boring">struct Player;
</span>fn level_selection_follow_player(
    players: Query&lt;&amp;GlobalTransform, With&lt;Player&gt;&gt;,
    levels: Query&lt;(&amp;LevelIid, &amp;GlobalTransform)&gt;,
    ldtk_projects: Query&lt;&amp;Handle&lt;LdtkProject&gt;&gt;,
    ldtk_project_assets: Res&lt;Assets&lt;LdtkProject&gt;&gt;,
    mut level_selection: ResMut&lt;LevelSelection&gt;,
) {
    if let Ok(player_transform) = players.get_single() {
        let ldtk_project = ldtk_project_assets
            .get(ldtk_projects.single())
            .expect(&quot;ldtk project should be loaded before player is spawned&quot;);

        for (level_iid, level_transform) in levels.iter() {
            let level = ldtk_project
                .get_raw_level_by_iid(level_iid.get())
                .expect(&quot;level should exist in only project&quot;);

            let level_bounds = Rect {
                min: Vec2::new(
                    level_transform.translation().x,
                    level_transform.translation().y,
                ),
                max: Vec2::new(
                    level_transform.translation().x + level.px_wid as f32,
                    level_transform.translation().y + level.px_hei as f32,
                ),
            };

            if level_bounds.contains(player_transform.translation().truncate()) {
                *level_selection = LevelSelection::Iid(level_iid.clone());
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migration-guides"><a class="header" href="#migration-guides">Migration Guides</a></h1>
<p>Most releases of <code>bevy_ecs_ldtk</code> introduce breaking changes.
For these, migration guides are provided to help users migrate their existing games to the new version.
If you're contributing a breaking change to <code>bevy_ecs_ldtk</code>, you may be asked to describe it in the appropriate migration guide.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrate-from-08-to-09"><a class="header" href="#migrate-from-08-to-09">Migrate from 0.8 to 0.9</a></h1>
<h2 id="bevy-upgrade"><a class="header" href="#bevy-upgrade">Bevy upgrade</a></h2>
<p><code>bevy_ecs_ldtk</code> has upgraded to Bevy and <code>bevy_ecs_tilemap</code> version <code>0.12</code>.
A Bevy <code>0.12</code> migration guide is available on <a href="https://bevyengine.org/learn/migration-guides/0.11-0.12/">Bevy's website</a>.</p>
<h2 id="ldtk-upgrade"><a class="header" href="#ldtk-upgrade">LDtk upgrade</a></h2>
<p><code>bevy_ecs_ldtk</code> now supports LDtk 1.5.3, and is dropping support for previous versions.
To update your game to LDtk 1.5.3, you should only need to install the new version of LDtk, open your project, and save it.</p>
<h2 id="default-behavior-for-ldtkentity-and-ldtkintcell-derive-macros"><a class="header" href="#default-behavior-for-ldtkentity-and-ldtkintcell-derive-macros"><code>Default</code> behavior for <code>LdtkEntity</code> and <code>LdtkIntCell</code> derive macros</a></h2>
<p>Fields on an <code>LdtkEntity</code>- or <code>LdtkIntCell</code>-derived bundle are no longer constructed from the field's <code>Default</code> implementation, but the bundle's.</p>
<p>You may observe different behavior in <code>0.9</code> if the value for a field in your bundle's <code>Default</code> implementation differs from the field type's own <code>Default</code> implementation:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span>#[derive(Component)]
struct MyComponent(usize);

impl Default for MyComponent {
    fn default() -&gt; MyComponent {
        MyComponent(1)
    }
}

#[derive(Bundle, LdtkEntity)]
struct MyBundle {
    component: MyComponent,
}

impl Default for MyBundle {
    fn default() -&gt; MyBundle {
        MyBundle {
            component: MyComponent(2),
        }
    }
}

// In bevy_ecs_ldtk 0.8, the plugin would spawn an entity w/ MyComponent(1)

// In bevy_ecs_ldtk 0.9, the plugin now spawns the entity w/ MyComponent(2)
<span class="boring">}</span></code></pre></pre>
<p>You may also need to implement <code>Default</code> for <code>LdtkEntity</code> types that did not have that implementation before:</p>
<pre><code class="language-rust ignore">// 0.8
#[derive(Bundle, LdtkEntity)]
struct MyBundle {
    component: MyComponentThatImplementsDefault,
}</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">use bevy::prelude::*;
</span><span class="boring">#[derive(Default, Component)]
</span><span class="boring">struct MyComponentThatImplementsDefault;
</span>// 0.9
#[derive(Default, Bundle, LdtkEntity)]
struct MyBundle {
    component: MyComponentThatImplementsDefault,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="hierarchy-of-ldtk-entities"><a class="header" href="#hierarchy-of-ldtk-entities">Hierarchy of LDtk Entities</a></h2>
<p>Layer entities (with a <code>LayerMetadata</code> component) are now spawned for LDtk Entity layers, just like any other layer.
By default, LDtk Entities are now spawned as children to these layer entities instead of as children of the level.</p>
<pre><code class="language-rust ignore">// 0.8
fn get_level_of_entity(
    entities: Query&lt;Entity, With&lt;EntityInstance&gt;&gt;,
    parent_query: Query&lt;&amp;Parent&gt;,
) {
    for entity in &amp;entities {
        println!(
            &quot;the level that {:?} belongs to is {:?}&quot;,
            entity,
            parent_query.iter_ancestors(entity).nth(0)
        );
    }
}</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">use bevy::prelude::*;
</span>// 0.9
fn get_level_of_entity(
    entities: Query&lt;Entity, With&lt;EntityInstance&gt;&gt;,
    parent_query: Query&lt;&amp;Parent&gt;,
) {
    for entity in &amp;entities {
        println!(
            &quot;the level that {:?} belongs to is {:?}&quot;,
            entity,
            parent_query.iter_ancestors(entity).nth(1)
        );
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="asset-type-rework"><a class="header" href="#asset-type-rework">Asset Type Rework</a></h2>
<p>Most breaking changes in this release are related to the asset types, previously <code>LdtkAsset</code> and <code>LdtkLevel</code>.
These types have been heavily reworked to improve code quality, correctness, performance, and provide better APIs.</p>
<h3 id="ldtkasset-is-now-ldtkproject-and-other-changes"><a class="header" href="#ldtkasset-is-now-ldtkproject-and-other-changes"><code>LdtkAsset</code> is now <code>LdtkProject</code>, and other changes</a></h3>
<p><code>LdtkAsset</code> has now been renamed to <code>LdtkProject</code>.
Any types and systems that depend on this type will need to be updated accordingly:</p>
<pre><code class="language-rust ignore">// 0.8
fn do_some_processing_with_ldtk_data(
    worlds: Query&lt;&amp;Handle&lt;LdtkAsset&gt;&gt;,
    ldtk_assets: Res&lt;Assets&lt;LdtkAsset&gt;&gt;
) {
    // do something
}</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">use bevy::prelude::*;
</span>// 0.9
fn do_some_processing_with_ldtk_data(
    worlds: Query&lt;&amp;Handle&lt;LdtkProject&gt;&gt;,
    ldtk_assets: Res&lt;Assets&lt;LdtkProject&gt;&gt;
) {
    // do something
}
<span class="boring">}</span></code></pre></pre>
<p>Furthermore, all of its fields have been privatized, and are now only available via immutable accessor methods.
Not all of these methods share the same name as their corresponding field in <code>0.8</code>:</p>
<pre><code class="language-rust ignore">// 0.8
let ldtk_json = ldtk_project.project;
let tileset_map = ldtk_project.tileset_map;
let int_grid_image_handle = ldtk_project.int_grid_image_handle;
let level_map = ldtk_project.level_map;</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">fn foo(ldtk_project: LdtkProject) {
</span>// 0.9
let ldtk_json = ldtk_project.json_data();
let tileset_map = ldtk_project.tileset_map();
let int_grid_image_handle = ldtk_project.int_grid_image_handle();
// the level_map is no longer available in the same way
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h3 id="ldtkasset-and-ldtkjson-level-accessor-methods-have-been-moved"><a class="header" href="#ldtkasset-and-ldtkjson-level-accessor-methods-have-been-moved"><code>LdtkAsset</code> and <code>LdtkJson</code> level accessor methods have been moved</a></h3>
<p>Level accessing methods have been completely redefined.
Analogues to existing methods have been renamed and moved to traits:</p>
<pre><code class="language-rust ignore">// 0.8
ldtk_json.iter_levels();

ldtk_asset.iter_levels();

ldtk_asset.get_level(&amp;LevelSelection::Uid(24));</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy_ecs_ldtk::{prelude::*, ldtk::LdtkJson};
</span><span class="boring">fn foo(ldtk_json: LdtkJson, ldtk_project: LdtkProject) {
</span>// 0.9
// in `RawLevelAccessor` trait:
ldtk_json.iter_raw_levels();

ldtk_project.iter_raw_levels();

// in `LevelMetadataAccessor` trait
ldtk_project.find_raw_level_by_level_selection(&amp;LevelSelection::Uid(24));
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<p>Many new methods have been provided as well.</p>
<h3 id="internal-levels-and-external-levels-support-now-behind-separate-features"><a class="header" href="#internal-levels-and-external-levels-support-now-behind-separate-features">Internal-levels and external-levels support now behind separate features</a></h3>
<p>There are two new cargo features, <code>internal_levels</code> and <code>external_levels</code>.
<code>internal_levels</code> is enabled by default and allows loading of internal-levels LDtk projects.
<code>external_levels</code> is not enabled by default and allows loading of external-levels LDtk projects.
Some APIs are unique to the two cases.</p>
<p>If you have an LDtk project with internal levels, but have disabled default features, you will need to enable <code>internal_levels</code>:</p>
<pre><code class="language-toml"># 0.8
bevy_ecs_ldtk = { version = &quot;0.8&quot;, default-features = false, features = [&quot;render&quot;] }

# 0.9
bevy_ecs_ldtk = { version = &quot;0.9&quot;, default-features = false, features = [&quot;render&quot;, &quot;internal_levels&quot;] }
</code></pre>
<p>If you have an LDtk project with external levels, you will need to enable <code>external_levels</code>:</p>
<pre><code class="language-toml"># 0.8
bevy_ecs_ldtk = &quot;0.8&quot;

# 0.9
bevy_ecs_ldtk = { version = &quot;0.9&quot;, features = [&quot;external_levels&quot;] }
</code></pre>
<p>These features are <strong>not</strong> mutually exclusive, but at least one of them must be enabled.</p>
<h3 id="level-asset-changes"><a class="header" href="#level-asset-changes">Level Asset Changes</a></h3>
<p>The level asset type has changed significantly.
Most importantly, it is no longer the primary mechanism for storing loaded level data.
In fact, it is only compiled and used within the <code>external_levels</code> feature (see previous section).</p>
<h4 id="level-entities-now-have-a-leveliid-instead-of-a-handleldtklevel"><a class="header" href="#level-entities-now-have-a-leveliid-instead-of-a-handleldtklevel">Level entities now have a <code>LevelIid</code> instead of a <code>Handle&lt;LdtkLevel&gt;</code></a></h4>
<p>The level asset it is no longer the main component marking level entities.
In both internal-levels and external-levels projects, level entities will no longer have a handle to the level asset, but instead will have a <code>LevelIid</code> component:</p>
<pre><code class="language-rust ignore">// 0.8
fn print_level_entity(levels: Query&lt;Entity, With&lt;Handle&lt;LdtkLevel&gt;&gt;&gt;) {
    for entity in &amp;levels {
        println!(&quot;level entity {:?} is currently spawned&quot;, entity);
    }
}</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">use bevy::prelude::*;
</span>// 0.9
fn print_level_entity(levels: Query&lt;Entity, With&lt;LevelIid&gt;&gt;) {
    for entity in &amp;levels {
        println!(&quot;level entity {:?} is currently spawned&quot;, entity);
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="accessing-level-data-from-the-level-entity"><a class="header" href="#accessing-level-data-from-the-level-entity">Accessing level data from the level entity</a></h4>
<p>Retrieving level data from the level entity can be done using the <code>LevelIid</code> component.
If the data you need <em>is not</em> inside the level's <code>layer_instances</code>, you can access it on the <code>LdtkProject</code> asset:</p>
<pre><code class="language-rust ignore">// 0.8
fn print_level_uid(levels: Query&lt;Handle&lt;LdtkLevel&gt;&gt;, level_assets: Res&lt;Assets&lt;LdtkLevel&gt;&gt;) {
    for level_handle in &amp;levels {
        let level_uid = level_assets.get(level_handle).unwrap().uid;
        println!(&quot;level w/ uid {level_uid}, is currently spawned&quot;);
    }
}</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">use bevy::prelude::*;
</span>// 0.9
fn print_level_uid(
    levels: Query&lt;&amp;LevelIid&gt;,
    projects: Query&lt;&amp;Handle&lt;LdtkProject&gt;&gt;,
    project_assets: Res&lt;Assets&lt;LdtkProject&gt;&gt;
) {
    for level_iid in &amp;levels {
        let only_project = project_assets.get(projects.single()).unwrap();

        let level_uid = only_project.get_raw_level_by_iid(level_iid.get()).unwrap().uid;
        println!(&quot;level w/ uid {level_uid}, is currently spawned&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>If the level data you need <em>is</em> inside the level's <code>layer_instances</code>, you may want to retrieve a <code>LoadedLevel</code>.
A <code>Level</code> might not have complete data - in the case that it's the &quot;raw&quot; level inside an external-levels project's <code>LdtkProject</code> asset.
This new <code>LoadedLevel</code> type provides type guarantees that the level has complete data.
For internal-levels (aka &quot;standalone&quot;) projects, you can retrieve loaded level data with a <code>LevelIid</code> and <code>LdtkProject</code> alone:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">use bevy::prelude::*;
</span>// 0.9, w/ internal_levels enabled
fn print_level_uid(
    levels: Query&lt;&amp;LevelIid&gt;,
    projects: Query&lt;&amp;Handle&lt;LdtkProject&gt;&gt;,
    project_assets: Res&lt;Assets&lt;LdtkProject&gt;&gt;
) {
    for level_iid in &amp;levels {
        let only_project = project_assets.get(projects.single()).unwrap();

        let layer_count = only_project
            .as_standalone()
            .get_loaded_level_by_iid(level_iid.get())
            .unwrap()
            .layer_instances()
            .len();
        println!(&quot;level has {layer_count} layers&quot;);
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For external-levels (aka &quot;parent&quot;) projects, you will need to additionally access the <code>LdtkExternalLevel</code> asset store:</p>
<pre><code class="language-rust ignore"><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">use bevy::prelude::*;
</span>// 0.9, w/ external_levels enabled
fn print_level_uid(
    levels: Query&lt;&amp;LevelIid&gt;,
    projects: Query&lt;&amp;Handle&lt;LdtkProject&gt;&gt;,
    project_assets: Res&lt;Assets&lt;LdtkProject&gt;&gt;
    level_assets: Res&lt;Assets&lt;LdtkExternalLevel&gt;&gt;,
) {
    for level_iid in &amp;levels {
        let only_project = project_assets.get(projects.single()).unwrap();

        let layer_count = only_project
            .as_parent()
            .get_external_level_by_iid(&amp;level_assets, level_iid.get())
            .unwrap()
            .layer_instances()
            .len();
        println!(&quot;level has {layer_count} layers&quot;);
    }
}</code></pre>
<h3 id="module-restructure"><a class="header" href="#module-restructure">Module restructure</a></h3>
<p>Some types related to assets have been removed, or privatized, or moved.</p>
<p>Those that were removed/privatized were generally not intended to be used by users:</p>
<ul>
<li><code>LevelMap</code></li>
<li><code>TilesetMap</code></li>
<li><code>LdtkLevelLoader</code></li>
<li><code>LdtkLoader</code></li>
</ul>
<p>Those that were moved have been moved into the <code>assets</code> module, and are still exposed in the <code>prelude</code>:</p>
<ul>
<li><code>LdtkProject</code></li>
<li><code>LdtkExternalLevel</code></li>
</ul>
<h2 id="leveliid-everywhere"><a class="header" href="#leveliid-everywhere"><code>LevelIid</code> everywhere</a></h2>
<p><code>LevelIid</code> is a new component on level entities that stores the level's iid as a string.
It has been reused throughout the API.</p>
<h3 id="in-levelset"><a class="header" href="#in-levelset">In <code>LevelSet</code></a></h3>
<p><code>LevelSet</code> uses it, but can still be constructed from strings using <code>from_iids</code>:</p>
<pre><code class="language-rust ignore">// 0.8
let level_set = LevelSet {
    iids: [
        &quot;e5eb2d73-60bb-4779-8b33-38a63da8d1db&quot;.to_string(),
        &quot;855fab73-2854-419f-a3c6-4ed8466592f6&quot;.to_string(),
    ].into_iter().collect(),
}</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">fn f() {
</span>// 0.9
let level_set = LevelSet::from_iids(
    [
        &quot;e5eb2d73-60bb-4779-8b33-38a63da8d1db&quot;,
        &quot;855fab73-2854-419f-a3c6-4ed8466592f6&quot;,
    ]
);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h3 id="in-levelevent"><a class="header" href="#in-levelevent">In <code>LevelEvent</code></a></h3>
<pre><code class="language-rust ignore">use std::any::{Any, TypeId};
// 0.8
fn assert_level_event_type(mut level_events: EventReader&lt;LevelEvent&gt;) {
    for level_event in level_events.iter() {
        use LevelEvent::*;
        let level_iid = match level_event {
            SpawnTriggered(level_iid) | Spawned(level_iid) | Transformed(level_iid) | Despawned(level_iid) =&gt; level_iid,
        };

        assert_eq!(level_iid.type_id(), TypeId::of::&lt;String&gt;());
    }
}</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">use bevy::prelude::*;
</span>use std::any::{Any, TypeId};
// 0.9
fn assert_level_event_type(mut level_events: EventReader&lt;LevelEvent&gt;) {
    for level_event in level_events.read() {
        use LevelEvent::*;
        let level_iid = match level_event {
            SpawnTriggered(level_iid) | Spawned(level_iid) | Transformed(level_iid) | Despawned(level_iid) =&gt; level_iid,
        };

        assert_eq!(level_iid.type_id(), TypeId::of::&lt;LevelIid&gt;());
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="in-levelselectioniid"><a class="header" href="#in-levelselectioniid">In <code>LevelSelection::Iid</code></a></h3>
<p><code>LevelSelection</code> uses it, but can still be constructed with a string via the <code>iid</code> method:</p>
<pre><code class="language-rust ignore">// 0.8
let level_selection = LevelSelection::Iid(&quot;e5eb2d73-60bb-4779-8b33-38a63da8d1db&quot;.to_string());</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">fn f() {
</span>// 0.9
let level_selection = LevelSelection::iid(&quot;e5eb2d73-60bb-4779-8b33-38a63da8d1db&quot;);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h2 id="levelselection-index-variant-now-stores-a-world-index"><a class="header" href="#levelselection-index-variant-now-stores-a-world-index"><code>LevelSelection</code> index variant now stores a world index</a></h2>
<p>The <code>LevelSelection::Index</code> variant has been replaced by <code>LevelSelection::Indices</code>.
Internally, this contains a new <code>LevelIndices</code> type, which stores an optional world index in addition to the level index.
However, you can still construct a <code>LevelSelection</code> from a single level index using the <code>index</code> method:</p>
<pre><code class="language-rust ignore">// 0.8
let level_selection = LevelSelection::Index(2);</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">fn f() {
</span>// 0.9
let level_selection = LevelSelection::index(2);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<h2 id="levelsetfrom_iid-replaced-with-levelsetfrom_iids"><a class="header" href="#levelsetfrom_iid-replaced-with-levelsetfrom_iids"><code>LevelSet::from_iid</code> replaced with <code>LevelSet::from_iids</code></a></h2>
<p><code>LevelSet::from_iid</code> has been replaced by <code>LevelSet::from_iids</code>.
This new method can accept any iterator of strings rather than just one:</p>
<pre><code class="language-rust ignore">// 0.8
let level_set = LevelSet::from_iid(&quot;e5eb2d73-60bb-4779-8b33-38a63da8d1db&quot;);</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">fn f() {
</span>// 0.9
let level_set = LevelSet::from_iids([&quot;e5eb2d73-60bb-4779-8b33-38a63da8d1db&quot;]);

// or many..
let level_set = LevelSet::from_iids(
    [
        &quot;e5eb2d73-60bb-4779-8b33-38a63da8d1db&quot;,
        &quot;855fab73-2854-419f-a3c6-4ed8466592f6&quot;,
    ]
);
<span class="boring">}
</span><span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="migrate-from-09-to-010"><a class="header" href="#migrate-from-09-to-010">Migrate from 0.9 to 0.10</a></h1>
<h2 id="bevy-upgrade-1"><a class="header" href="#bevy-upgrade-1">Bevy upgrade</a></h2>
<p><code>bevy_ecs_ldtk</code> has upgraded to Bevy and <code>bevy_ecs_tilemap</code> version <code>0.14</code>.
A Bevy <code>0.14</code> migration guide is available on <a href="https://bevyengine.org/learn/migration-guides/0-13-to-0-14/">Bevy's website</a>.</p>
<h2 id="spritesheetbundle-replaced-with-ldtkspritesheetbundle"><a class="header" href="#spritesheetbundle-replaced-with-ldtkspritesheetbundle"><code>SpriteSheetBundle</code> replaced with <code>LdtkSpriteSheetBundle</code></a></h2>
<p>In <code>0.14</code>, Bevy depricated <code>SpriteSheetBundle</code> to clear up confusion for new users. To maintain existing functionality with the <code>#[sprite_sheet_bundle]</code> macro, <code>SpriteSheetBundle</code> has been re-implemented as <code>LdtkSpriteSheetBundle</code></p>
<pre><code class="language-rust ignore">// 0.9
#[derive(Default, Bundle, LdtkEntity)]
struct PlayerBundle {
    player: Player,
    #[sprite_sheet_bundle]
    sprite_bundle: SpriteSheetBundle,
    #[grid_coords]
    grid_coords: GridCoords,
}</code></pre>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 0.10
<span class="boring">use bevy_ecs_ldtk::prelude::*;
</span><span class="boring">use bevy::prelude::*;
</span>#[derive(Default, Bundle, LdtkEntity)]
struct PlayerBundle {
    #[sprite_sheet_bundle]
    sprite_bundle: LdtkSpriteSheetBundle,
    #[grid_coords]
    grid_coords: GridCoords,
}
<span class="boring">}</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><meta http-equiv="Refresh" content="0; url='https://docs.rs/bevy_ecs_ldtk/'" />

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
